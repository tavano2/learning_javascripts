/*
이번 섹터에서는 자바스크립트가 어떤 방식으로 작동하는지에 대해 공부해보자.
먼저 최근에 사용하는 ES5 vs ES6 + Syntax에 관련하여 살펴보자.

- ES5 VS ES6 + Syntax

    ES5와 ES6의 차이점은 뭘까?
    ES는 ECMAScript를 의미한다.
    ECMAScript는 javascript를 뒷받침하는 언어라고 할 수 있는데
    해당 스크립트 언어가 자바스크립트에 기능을 넣고 빼고 결정하는 핵심 언어이고
    브라우저는 결정된 내용을 javascript 엔진에 반영한다.

    ES5는 ECMAScript 버전5로 2015년 이전에 주로 사용되던 언어였으며
    ECMAScript2015버전을 ES6라고 부른다.

    ES5와 6의 가장 큰 차이점 중 하나는 변수를 선언할 때
    ES5는 const나 let 키워드가 없고 var로 호출한다.

- var vs let vs const <- app.js 참고

    var : 변동 가능한 변수 생성, ES6이전에도 사용 가능, var는 함수 & 전역 스코프 사용
    let : 변동 가능한 변수 생성, ES6 이후에 사용 가능, let은 block(문장 -> 중괄호) 스코프 사용
    const : 변동 불가능한 변수 생성(상수), const는 block scope 사용

    또한 var와 let,const의 읽고 초기화 하는 방법이 다르다.

- 호이스팅

    javascript에는 호이스팅이라는 특별한 기능이 존재한다.
    호이스팅은 함수나 변수 같은 선언들을 코드라인보다 윗줄로
    옮겨 정상적으로 실행될 수 있게 한다.

    이 과정에서 let이나 const는 undefined로 초기화하지 않는다.
    이는 코드의 가독성을 높이기 위해 ES6부터 강제된 것으로
    var는 강제하지 않았기에 만일 위와 같은 코드가 작성되었고 중간 코드가 매우 많다면
    해당 로그를 찾기 복잡했을 것이다.

- let과 const는 코드를 강제한다!

    var는 추가적으로 같은 명칭을 써서 무한대로 중복 초기화가 가능하고
    변수 키워드를 선언하지 않았을 경우 자바스크립트에서는 var로 인식하여 선언하고 로직을 호출한다.
    이는 코딩 과정에서 많은 버그를 일으킬 수 있어, let과 const 같이 일부를 강제할 수 있는 변수를 사용하는 것이 좋다.
    추가적으로 var 선언 변수명에 예약어도 사용될 수 있는 자유도도 존재한다.

- 엄격모드

    이런 관대함을 강제하기 위해 자바스크립트에서는 엄격 모드를 on/off 가능하다.
    "use strict";
    브라우저는 위 코드를 인식하여 엄격 모드를 활성화한다.

- 자바스크립트의 깨끗한 코딩 방법

    let과 const 문법을 사용하여 작성하자.
    관대한 언어라는 것은 좋은 말처럼 들리지만 프로그래밍에서는 그렇지 않다.
    더 깔끔한 코딩 방법을 위해 ECMA에서도 노력하고 있음을 기억하자.
*/

/*
- 자바스크립트 실행 & 작동 원리

    1. my code
        const name = "Max";
        alert(name);
    2. html로 임포트 되어 브라우저에서 인라인 스크립트를 읽기 시작함
    3. 자바스크립트를 파싱후 실행 (인터프리터)
    4. 인터프리터가 실행한 바이트코드를 컴파일러가 실행 (JiT 컴파일러)
    5. 바이트 코드를 머신에 컴파일하여 머신 코드로 변환 후 빠르게 운영체제로 전달
    6. 컴파일러의 큰 장점은 이미 한번 컴파일된 코드는 재사용하여 반복되는 작업을 줄여 성능을 향상시킨다.
- 코드 실행의 자세한 원리
    1. my code 실행시 메모리와 실행 단계에 대한 관리가 이루어짐 (heap, stack)
    2. heap - 장기 메모리, stack - 프로그램 흐름 관리(함수)
    3. event loop -> 이벤트 리스너를 지원하여 비동기 실행 가능
       해당 루프는 자바스크립트 엔진이 아닌 브라우저에서 지원한다.

*/


/*
- ★ 원시 vs 참조값

    자바스크립트에서 다른 개념은 몰라도 해당 개념은 꼭 숙지하고 넘어가야 한다.
    자바스크립트에는 자료형 또는 값 이라는 두 가지 카테고리가 있다.
    즉 문자열, 숫자, 불리언, 객체, null, undefined등으로 2개의 카테고리로 나눌 수 있다.
    바로 원시 값과 참조 값이다.

    두 개의 주요 차이점은 데이터의 6개 자료형이 원시 값에 속한다.
        - Strings, Numbers, Booleans, null, undefined, Symbol(나중에 배움)
    
    원시 값은 메모리에 저장되고 보통 스택에 저장된다. (실행 시간이 긴 경우 힙에 저장될 수도 있음)
    원시 값은 복사 될 시에 실제로 복사되는 것은 그 값이다.
    즉 a원시값을 b 변수에 저장했을시 완전히 값이 복사된다.

    참조 값
        - 해당 6개를 제외한 모든 오브젝트

    참조 값은 말 그대로 변수에 참조하는 것이기 때문에
    a 참조값을 b 변수에 저장했을시 해당 주소(포인터 저장)가 복사되어
    a 값을 변경하면 b 변수에 있는 값도 변경된다.
    참조 값은 보통 힙으로 저장된다. 
    만일 참조가 아닌 복사를 하고 싶을떄는 전개 연산자(...)를 사용하여 깊은 복사를 사용한다.
    const newArray = [...oldArray];
    const newObject = { ...oldObject };
    
    let과 const를 운용할떄 참조 값에서 헷갈리는 경우가 있을 수 있다.
    const 사용시에도 메모리 자체 주소는 변하지 않기 떄문에
    객체 내부 값들을 함수로 변경 가능하다.(push, .{value} 등등)
    하지만 = 연산자를 사용하여 변경하려 할 시에는 에러가 발생한다.
*/

/*
- 가비지 컬렉터

    스택은 금방금방 메모리가 초기화 되므로 잠시 잊자.
    힙은 메모리 관리를 어떻게 진행할까?
    자바스크립트는 v8이라는 가비지 컬렉터로 메모리를 관리한다.

    가비지 컬렉터는 주기적으로 사용되지 않은 객체를 확인하고
    (사용되지 않은 객체 -> 참조되지 않은 객체)
    사용되지 않은 객체를 메모리에서 제거한다.

    예를 들어 참조한 주소를 사용하지 않을 때 가비지 컬렉터가 동작하여
    해당 객체에 대한 주소, 포인터를 어디에서도 사용하지 않는다고 감지, 제거한다.

    이벤트 리스너의 경우 버튼 클릭시 리스너를 실행시키는 경우에는
    클릭때 마다 리스너가 추가 될 것이라 생각할 수 있지만
    JS와 브라우저가 알고리즘을 통해 한번만 리스너를 실행한다.
    (더 자세하게는 새로운 리스너로 교체한다.)

    하지만 간접 함수가 아닌 익명 함수로 리스너를 등록하는 경우에는
    지속적으로 리스너가 등록 되기 때문에, 메모리 누수가 일어날 수 있음을 기억하자.
*/