// 함수에 대해 좀 더 알아보기

/*
- 함수 생성에 다양한 방식
    먼저 함수 정의에 대해 다시 복습해보자.
    1. 함수는 온디맨드 형식(프로그램의 흐름 중에서 필요한 시점에만 실행되도록 하는 형식)으로 코드를 정의하는 구조이다.
    2. 함수 내에서 상수나 변수를 생성하면 해당 함수 소속된다. (블록 스코프)
    3. 함수는 인수라는 매개변수를 취해 값을 반환하는데, 함수 내에서 어느 것도 하지 않고 매개변수를 반환 가능하며,
       매개변수를 취하지 않고 아무것도 반환하지 않는 함수도 작성할 수 있다.
    4. 함수는 훌륭한 동적 온디맨드 코드이다. (인수를 매번 다르게 받지만 같은 코드를 중복적으로 활용 가능)
    5. 함수는 직접,간버으로 호출할 수 있다. (직접호출 : ()를 사용하여 호출 간접호출 : 이벤트 리스너를 통해 바인딩하거나, 컴포넌트에 바인딩하여 사용)

- 메서드
    메서드란 무엇일까? 메서드는 객체에 함수가 저장된 것을 말한다.
    여기서 헷갈릴 수 있지만 메서드 역시 객체임을 이해하자.
    함수 역시 객체임을 배웠으므로 함수 = 객체 = 메서드임을 알아두자.

- 변수에 함수 저장하기
    ES5까지는 전역 스코프 개념 때문에 변수에 함수를 저장하더라도 이벤트 리스너에 함수명을 넣으면 동작했지만
    ES6부터는 저장한 변수명을 호출해야 동작한다.
    저장하는 변수에 함수명을 생략할 수 있는데, 이런 함수가 익명 함수라고 불린다.

- 함수 표현식 vs 선언
    선언문 ex)
    fuction multiply(a, b) {
        return a * b;
    }
    표현식 ex)
    const multiply = function(a, b) {
        return a * b;
    };

    선언 형식을 자바스크립트 엔진이 hoist를 통해 파일의 맨 위로 초기화를 진행한다.
    하지만 표현식은 표현식 자체를 작성할 때 초기화가 되므로, 초기화 되기 이전의 코드라인에서 호출이 불가능하다.
    
- 익명 함수
    익명 함수란 말 그대로 함수명이 없는 함수를 말한다.
    이벤트 리스너나 객체안에서 주로 사용하는데, 해당 리스너나 객체를 딱 한번만 사용할 때
    추후 코드를 확인한 개발자가 참조로 넣은 함수를 따로 찾을 필요가 없는 편리함을 제공해줄 수 있다.

    하지만 코드라인이 길거나 복잡한 경우 익명함수를 권장하지 않는데,
    익명함수에서 에러가 발생할 경우 어떤 함수에서 문제가 발생했는지 나오지 않는다.

- 화살표 함수
    app.js에 getWinner 변수를 보면 화살표 함수로 정의했다.
    해당 함수의 특징은 무엇일까?
    화살표 함수의 장점은 다양한 방식으로 설계할 수 있다는 것이다.
    또한 function 키워드를 생략할 수 있어 더 짧은 코드를 작성 가능하다.
    그리고 간단하게 반환문으로 바로 사용할 수 있는 코드라면 중괄호와 return을 생략할 수 있다.

    ex)
        const add = (a, b) => a + b;
        const add2 = function(a, b) {
            return a + b;
        }
        
- 함수 내의 기본 인자
    자바스크립트의 경우 다른 언어와 다르게 함수의 인자를 누락할시에
    누락된 값을 undefined로 사용한다.
    이럴 경우 기본 인자응 설정할 수 있는데
        ex) const fn = (a, b = default value) { ... }
    위와 같이 지정하면 기본 인자가 들어간다.

    만일 인자를 누락하지 않고, undefined로 인자를 보낼시에도 설정한 값으로 변경된다.
    하지만 null이나 다른 falsy 값으로 인자를 보내면 해당 인자가 그대로 사용되는 것을 기억하자.

- rest 연산자 <- app.js sumUp, subUp 함수 확인
    함수에서 많은 파라미터를 넣어 호출했을 때 해당 파라미터를 인수로 지정하지 않고 전부 사용하는 방법이 존재할까?
    이럴 때 rest 연산자를 사용한다.
        ex) const fn = (...args) => { console.log(args) }
    위와 같이 호출하게 되면 함수 호출시 파라미터들이 배열로 저장되어 args에 참조된다.
    rest 연산자에 대해 중요한 점은 해당 연산자가 마지막 인수로 들어가야 한다는 점이다.
        ex) const fn = (a, b, ...args) => { for.. sum(args) }
    위와 같은 합산 함수를 만들었을시 첫 두개의 인수는 args에 포함되지 않으므로 호출시 합산 값이 달라질 수 있음을 이해하자.
    
    또 하나의 특별한 키워드는
    function 키워드를 선언하고 진행하는 코드의 경우
    인수 내에 rest 연산자를 사용하지 않고, 코드 블랙 내부에 arguments라는 예약어를 사용시에도 동일하게 사용할 수 있다.
    하지만 이 방식은 ES5 이전의 방식이므로 rest 연산자를 사용할 것을 권장한다.

- 중첩 함수
    당연한 소리지만 함수 내에 함수도 작성 가능하다.
    보통은 스크립트 루트 레벨에 함수를 지정하기에 심화 과정에서 좀 더 알아보자.

- 콜백 함수 <- app.js callBackSumUp 참고
    콜백 함수란 지금까지 사용했던 이벤트 리스너 함수와 같이
    어떠한 액션에 의해 불러와지고 언제 호출이 되는지 마음대로 할 수 없다.
    이에 간접 함수를 넣어, 해당 액션이 이뤄질 때 간접 함수를 호출하는 개념이다.

    특히 자바스크립트가 지원하는 많은 빌트인 함수들은 콜백 형태로 지원되니
    해당 형태를 이해하는 것이 필요하다.

- bind <- app.js combine, showResult 참고
    만일 콜백 함수를 간접 호출할 때 인수를 바인딩할 수 있는 방법은 없을까? (인수의 사전 구성)
    이럴 때 간접함수 호출시 bind 메서드와 같이 호출하여 사용 가능하다.
- apply, call
    bind는 준비하는 동작이라면, apply와 call은 곧바로 실행하는 메소드이다.
    좀 더 심화 과정에서 다룰 예정이니, bind와 함꼐 자주 사용되는 메소드라고 알아두자.

*/